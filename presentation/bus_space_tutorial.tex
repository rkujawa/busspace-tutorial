%
% Copyright (c) 2012 The NetBSD Foundation, Inc.
% All rights reserved.
%
% This code is derived from software contributed to The NetBSD Foundation
% by Radoslaw Kujawa.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
% 1. Redistributions of source code must retain the above copyright
%    notice, this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright
%    notice, this list of conditions and the following disclaimer in the
%    documentation and/or other materials provided with the distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
% ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
% TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
% PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%
%
% Presentation for NetBSD drivers tutorial for Snow B.V.
%
% TeX layout based on examples provided by Jean-Yves Migeon
%
% The following people provided important suggestions and corrections: 
% Greg Oster, Valery E. Ushakov, S.P. Zeidler
%
% 
\documentclass[dvipsnames,table]{beamer}

\usetheme{Rochester}
\usecolortheme{orchid}

\usepackage{listings}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{wasysym}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{hyperref}

\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{caption}[numbered]
\setbeamerfont{caption}{size=\scriptsize}
\setbeamercolor{framenote}{bg=NetBSD-orange!25}
\setbeamercolor{rednote}{bg=Red!25}
\setbeamercolor{palette primary}{use=structure,fg=white,bg=NetBSD-orange}
\setbeamercolor{palette secondary}{use=structure,fg=white,bg=NetBSD-orange2}

\setbeamertemplate{itemize item}{\scriptsize\raise1pt\hbox{\donotcoloroutermaths$\blacktriangleright$}}
\setbeamertemplate{itemize subitem}{\tiny\raise1pt\hbox{\donotcoloroutermaths$\bullet$}}
\setbeamertemplate{itemize subsubitem}{\tiny\raise1pt\hbox{\donotcoloroutermaths{--}}}

\setbeamertemplate{enumerate item}{\insertenumlabel.}
\setbeamertemplate{enumerate subitem}{\insertenumlabel.\insertsubenumlabel}
\setbeamertemplate{enumerate subsubitem}{\insertenumlabel.\insertsubenumlabel.\insertsubsubenumlabel}
\setbeamertemplate{enumerate mini template}{\insertenumlabel}

\setbeamercolor{itemize item}{fg=NetBSD-orange, bg=NetBSD-orange}
\setbeamercolor{itemize subitem}{fg=NetBSD-orange, bg=NetBSD-orange}
\setbeamercolor{itemize subsubitem}{fg=NetBSD-orange, bg=NetBSD-orange}

\setbeamercolor{section number projected}{fg=white,bg=NetBSD-orange}
\setbeamercolor{subsection number projected}{fg=white,bg=NetBSD-orange}
\setbeamercolor{button}{bg=NetBSD-orange,fg=white}

\setbeamertemplate{section in toc}[circle]
\setbeamertemplate{subsection in toc}[square]


\definecolor{NetBSD-orange}{RGB}{242,103,17}
\definecolor{NetBSD-orange2}{RGB}{177,76,12}
\hypersetup{colorlinks=true,linkcolor=white,urlcolor=NetBSD-orange}

\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.2}

\newcommand{\nbsdcolor}[1] {
	{\color{NetBSD-orange} #1}
}

\lstset{
   language=C,
   basicstyle=\tiny,
   breaklines=true,
   escapechar=\@,
   commentstyle=\color{NetBSD-orange}
}

\AtBeginSection[]{
%\begin{frame}
%\begin{center}
%\Huge fooo \insertsection
%\end{center}
%\end{frame}
\frame{\sectionpage}

}

\title{Writing NetBSD drivers -- a crash course}

\author{Radoslaw Kujawa -- rkujawa@NetBSD.org}

\institute{The NetBSD Foundation}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Table of Contents}
{
\hypersetup{colorlinks=true,linkcolor=black,urlcolor=NetBSD-orange}
\tableofcontents
}
\end{frame}

\section{Introduction}

\begin{frame}
\frametitle{About this tutorial}
\begin{itemize}
	\item Why did I create this tutorial?
	\begin{itemize}
		\item Writing device drivers is often considered black magic
		\item Kernel-level programming is generally discouraged
		\item Reading the {\tt man} pages won't give you the big picture
		\item BSD systems are always in need of new drivers
		\item Device drivers are fun {\Large \smiley}
	\end{itemize}
	\item Originally this tutorial was delivered at EuroBSDcon 2012 (this is a shortened version)
\end{itemize}
\end{frame}


\subsection{Basic concepts}

\begin{frame}
\frametitle{Basic concepts}
\begin{itemize}
	\item What is a driver anyway?
	\begin{itemize}
		\item The interface between user space and hardware, implemented as a part of the kernel
		\item The NetBSD drivers are written mostly in C
		\item Sometimes they have machine dependent assembler parts, but this is a rare case
	\end{itemize}
	\item What do you need to write a driver?
	\begin{itemize}
		\item C programming skills, good understanding of OS and computer architecture
		\item Hardware documentation (or the ability to reverse engineer the hardware)
		\item A reference driver implementation will help but is not essential
		\item A NetBSD installation and kernel source, or a cross-build environment (the latter is usually preferred for development of drivers)
		\item A lot of time, coffee and patience {\Large \smiley}

	\end{itemize}
\end{itemize}
\end{frame}

\subsection{The NetBSD driver model}

\begin{frame}
\frametitle{The NetBSD kernel structure}
\begin{itemize}
	\item NetBSD has a classic monolithic UNIX-like kernel - all drivers are running in the same address space
	\item Numerous in-kernel frameworks standardise the way drivers are written ({\tt bus\_space}, {\tt autoconf}, etc.) 
	\item High quality, machine-independent (MI) drivers are an important factor that adds to NetBSD portability
	\item We'll only cover kernel parts interesting for a device driver programmer
	\begin{itemize}
	\item {\tt src/sys/} - kernel source directory
	\item {\tt src/sys/dev/} - machine-independent device drivers
	\item {\tt src/sys/arch/} - port-specific or architecture-specific parts (such as the low-level system initialisation procedures or machine-dependent drivers)
	\item {\tt src/sys/arch/\$PORTNAME/conf/} - kernel configuration files for a given port
	\end{itemize}

\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Kernel autoconfiguration framework - autoconf(9)}
\begin{itemize}
	\item Autoconfiguration is the process of matching hardware devices with an
     appropriate device driver
    \item The kernel message buffer (dmesg) contains information about autoconfiguration of devices
    \item {\tt driver0 at bus0: Foo hardware} 
    \begin{itemize}
    	\item Instance 0 of the driver has attached to instance 0 of the particular bus
		\item Such messages often carry additional bus-specific information about the exact location of the device (like the device and function number on the PCI bus)
	\end{itemize}
    \item {\tt driver0: some message}
    \begin{itemize}
    	\item Additional information about the driver state or device configuration
	\end{itemize}
	\item Let's see how it looks like...
\end{itemize}
\end{frame}

\section{Example driver from scratch}

\subsection{Development environment}

\begin{frame}
\frametitle{Development environment}
\begin{itemize}
	\item Out of scope of this course, but very well documented
	\item Cross compiling is an easy task with the {\tt build.sh} script
	\item Described in \href{http://www.netbsd.org/docs/guide/en/part-compile.html}{Part V of the NetBSD Guide}
	\item Check out the NetBSD sources
	\item {\tt \$ build.sh -m cobalt tools} will build compiler, assembler, linker, etc. for cobalt port
	\item {\tt \$ build.sh -m cobalt kernel=GENERIC} will build the GENERIC kernel for cobalt
	\item Call {\tt build.sh} with a {\tt -u} parameter to update (won't rebuilding everything)
	\item {\tt build.sh} is calling {\tt nbconfig} and {\tt nbmake} tools, no magic involved
\end{itemize}
\end{frame}

\subsection{Our hardware - a fake PCI card}

\begin{frame}
\frametitle{Our hardware - technical details}

\begin{itemize}
\item Functional description
\begin{itemize}
	\item Business applications often use arithmetic operations like addition
	\item Fake Cards Inc. responded to market needs and created a new product, Advanced Addition Accelerator
	\item Pointy Haired Bosses will certainly buy it to accelerate their business applications, so let's create a driver for NetBSD!
\end{itemize}
\item Technical details
\begin{itemize}
	\item Implemented as a PCI device
	\item Arithmetic unit capable of addition of two numbers
	\item Three registers in the PCI memory space
\end{itemize}
\item PCI configuration space
\begin{itemize}
	\item Identified by the PCI vendor ID {\tt 0xfabc} and product ID {\tt 0x0001}
	\item Base Address Register 0x10 used to configure the engine address 
	\item 4 x 32-bit registers = 16 bytes
	\item Other configuration registers irrelevant
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\label{faaop}
\frametitle{Our hardware - technical details (memory mapped register set)}
\begin{itemize}
	\item Advanced Addition Acceleration registers
\end{itemize}
\tiny
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Register Name & Offset & Description \\
\hline
\hline
COMMAND & 0x4 & Register used to issue commands to the engine \\
\hline
DATA & 0x8 & Register used to load data to internal engine registers \\
\hline
RESULT & 0xC & Register used to store the result of arithmetic operation \\
\hline
\end{tabular}
\end{center}
\begin{itemize}
	\item COMMAND register 
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Bit & R/W & Description \\
\hline
\hline
0 & W & Execute ADD operation on values loaded into internal register A and B \\
\hline
1 & R/W & Select internal register A for access through DATA register  \\
\hline
2 & R/W & Select internal register B for access through DATA register \\
\hline
\end{tabular}
\end{center}

\begin{itemize}
	\item DATA register
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Bit & R/W & Description \\
\hline
\hline
0:31 & R/W & Read/write the value in internal engine register \\
\hline
\end{tabular}
\end{center}

\begin{itemize}
	\item RESULT register 
\end{itemize}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Bit & R/W & Description \\
\hline
\hline
0:31 & R & Holds the result of last ADD operation \\
\hline
\end{tabular}
\end{center}

\end{frame}

\begin{frame}
\frametitle{Our hardware - technical details (operation algorithm)}
\begin{itemize}
	\item Select the internal register {\tt A} for access (write {\tt 0x2} into {\tt COMMAND} register)
	\item Write the first number into {\tt DATA} register
	\item Select the internal register {\tt B} for access (write {\tt 0x4} into {\tt COMMAND} register)
	\item Write the second number into {\tt DATA} register
	\item Issue the {\tt ADD} operation (write {\tt 0x1} into {\tt COMMAND} register)
	\item Read the result from {\tt RESULT} register

\end{itemize}
\end{frame}

\subsection{Adding a new driver to the NetBSD kernel}

\begin{frame}
\frametitle{Adding a new driver to the NetBSD kernel}
\begin{itemize}
	\item We'll discuss the steps needed to add a new MI PCI device driver to the NetBSD kernel
	\begin{itemize}
		\item Add the vendor and device ID to the database of PCI IDs
		\item Create a set of the driver source files in {\tt src/sys/dev/\$BUSNAME/ }
		\item Add the new driver to {\tt src/sys/dev/\$BUSNAME/\$BUSNAME.files} file
		\item Add the new driver to {\tt DEVNAMES}\footnote{Required if you are NetBSD developer, optional otherwise.} file
	\end{itemize}
\end{itemize}
\end{frame}

\subsection{Matching and attaching the PCI device}

\begin{frame}[fragile]
\frametitle{Modifying the PCI device database}
\begin{verbatim}
unmatched vendor 0xfabc product 0x0001 (Co-processor 
processor, revision 0x01) at pci0 dev 12 function 0 
not configured
\end{verbatim}
\begin{itemize}
	\item The kernel does not know anything about this vendor and device
	\item Add it to the PCI device db - {\tt src/sys/dev/pci/pcidevs}
	\item {\tt vendor VENDORNAME 0xVENDORID Long Vendor Name}
	\item {\tt product VENDORNAME PRODUCTNAME 0xPRODUCTID	Long Product Name}
	\item To regenerate pcidevs*.h run {\tt awk -f devlist2h.awk pcidevs} or
{\tt Makefile.pcidevs} if you're on NetBSD

\end{itemize}
\begin{verbatim}
Fake Cards Advanced Addition Accelerator (Co-processor 
processor, revision 0x01) at pci0 dev 12 function 0 
not configured
\end{verbatim}
\end{frame}

\begin{frame}
\frametitle{Adding the new PCI driver}
\begin{itemize}
	\item Choose a name - short, easy to remember, avoid numbers
	\begin{itemize}
		\item {\tt faa} looks like a good name, but you can choose any name you like
	\end{itemize}
	\item Create a set of new files in {\tt src/sys/dev/pci}
	\begin{itemize}
		\item {\tt faa.c} - main driver code
		\item {\tt faareg.h} - register definitions\footnote{Might not exist if the driver is only a simple passthrough from a specific bus to another MI driver.}
		\item {\tt faavar.h} - driver structures and functions used in other parts of the kernel\footnote{Omitted if not needed.}
	\end{itemize}
	\item Modify driver definitions
	\begin{itemize}
		\item {\tt src/sys/dev/pci/files.pci}
		\item {\tt src/sys/dev/DEVNAMES}
	\end{itemize}
	\item Configure the kernel to use the newly added driver - {\tt src/sys/arch/\$PORTNAME/conf/GENERIC}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adding the new PCI driver - main driver}
\begin{itemize}
	\item Kernel includes are at the beginning, followed by machine-specific and bus-specific includes
	\item Should also include {\tt faareg.h} and {\tt faavar.h} files
	\item A minimal driver needs just two functions
	\begin{itemize}
		\item {\tt static int faa\_match(device\_t parent, cfdata\_t match, void *aux);}
		\item {\tt static void faa\_attach(device\_t parent, device\_t self, void *aux);}
	\end{itemize}
	\item The {\tt CFATTACH\_DECL\_NEW} macro plugs the above functions into {\tt autoconf(9)} mechanism, for example:
	{\tt CFATTACH\_DECL\_NEW(faa, sizeof(struct faa\_softc),
    faa\_match, faa\_attach, NULL, NULL);}
	
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding the new PCI driver - main driver example}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD$");
#include <sys/param.h>
#include <sys/device.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/faareg.h>
#include <dev/pci/faavar.h>

static int      faa_match(device_t, cfdata_t, void *);
static void     faa_attach(device_t, device_t, void *);

CFATTACH_DECL_NEW(faa, sizeof(struct faa_softc),
    faa_match, faa_attach, NULL, NULL);

static int
faa_match(device_t parent, cfdata_t match, void *aux)
{
        return 0;
}

static void
faa_attach(device_t parent, device_t self, void *aux)
{ 
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding the new PCI driver - auxiliary includes}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/pci/faareg.h}
\end{itemize}
\begin{lstlisting}
#ifndef FAAREG_H
#define FAAREG_H
/* 
 * Registers are defined using preprocessor:
 * #define FAA_REGNAME	0x0
 * We'll add them later, let's leave it empty for now.
 */
#endif /* FAAREG_H */
\end{lstlisting}
\begin{itemize}
	\item {\tt src/sys/dev/pci/faavar.h}
\end{itemize}
\begin{lstlisting}
#ifndef FAAVAR_H
#define FAAVAR_H

/* sc_dev is an absolute minimum, we'll add more later */
struct faa_softc {
        device_t sc_dev;
};
#endif /* FAAVAR_H */
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding the new PCI driver - registering the driver}
\scriptsize
\begin{itemize}
	\item See {\tt config(5)}
	\item {\tt src/sys/dev/pci/files.pci}
\end{itemize}
\begin{verbatim}
--- pci/files.pci	2 Aug 2012 00:17:44 -0000	1.360
+++ pci/files.pci	6 Oct 2012 19:59:10 -0000
@@ -1122,3 +1122,9 @@
 device	tdvfb: wsemuldisplaydev, rasops8, vcons, videomode
 attach	tdvfb at pci
 file	dev/pci/tdvfb.c		tdvfb	
+
+# FakeCards Advanced Addition Accelerator
+device	faa
+attach	faa at pci
+file	dev/pci/faa.c		faa	
+
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding the new PCI driver to the kernel configuration}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/arch/cobalt/conf/GENERIC}
\end{itemize}
\begin{verbatim}
--- GENERIC	10 Mar 2012 21:51:50 -0000	1.134
+++ GENERIC	6 Oct 2012 20:12:37 -0000
@@ -302,6 +302,9 @@
 #fms*		at pci? dev ? function ?	# Forte Media FM801
 #sv*		at pci? dev ? function ?	# S3 SonicVibes
 
+# Fake Cards Advanced Addition Accelerator
+faa*		at pci? dev ? function ?
+
 # Audio support
 #audio*		at audiobus?
\end{verbatim}
\normalsize
\begin{itemize}
	\item The above definition means that an instance of {\tt faa} may be attached to any PCI bus, any device, any function
	\item The exact position of the rule in the configuration file is not important in this case
	\item See \href{http://netbsd.gw.com/cgi-bin/man-cgi?config+5+NetBSD-current}{config(5)} for a description of the device definition language
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Matching the PCI device}
\begin{itemize}
	\item The driver's match function will check if the driver is able to work with a given device
 	\item Since it is not implemented, the kernel will not attach the driver
	\item Modify the {\tt faa\_match} function to match the specified PCI device
\end{itemize}
\scriptsize
\begin{lstlisting}
static int
faa_match(device_t parent, cfdata_t match, void *aux)
{
        const struct pci_attach_args *pa = (const struct pci_attach_args *)aux;

        if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_FAKECARDS) 
            && (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_FAKECARDS_AAA))
                return 1;

        return 0;
}
\end{lstlisting}
\normalsize
\begin{itemize}
	\item The driver has successfully matched and attached to the device
\end{itemize}
\begin{verbatim}
faa0 at pci0 dev 12 function 0
\end{verbatim}
\end{frame}


\begin{frame}
\frametitle{Variable types used with {\tt bus\_space}}

\begin{itemize}
         \item {\tt bus\_space\_tag\_t} -- type used to describe a particular bus, usually passed to the driver from MI bus structures
         \item {\tt bus\_space\_handle\_t} --  used to describe a mapped range of bus space, usually created with the {\tt bus\_space\_map()} function
         \item {\tt bus\_addr\_t} -- address on the bus
         \item {\tt bus\_size\_t} -- an amount of space on the bus
         \item Contents of these types are opaque, so avoid modifying from within the driver\footnote{although you'll often have to use {\tt bus\_size\_t}}
\end{itemize}
\end{frame}


\subsection{Mapping the hardware resources}


\begin{frame}[fragile]
\frametitle{Mapping the hardware resources}

\begin{itemize}
	\item ``The bus space must be mapped before it can be used, and should be unmapped       when it is no longer needed''
%	\item The kernel has its own virtual address space
%	\item Physical space can be made visible in kernel virtual address space through the process of mapping
\normalsize
	\item It's a machine-dependent process but it's also conveniently hidden from the programmer by the bus\_space framework
	\item The generic bus\_space(9) way to map space
\begin{itemize}
	\scriptsize
	\item
\begin{verbatim}
bus_space_map(bus_space_tag_t space, bus_addr_t address, 
bus_size_t size, int flags, bus_space_handle_t  *handlep);
\end{verbatim}
	\normalsize
	\item {\tt bus\_space\_map} creates a mapping from the physical address to a kernel virtual address
\end{itemize}

	\item The PCI-specific way to map space
\begin{itemize}
	\scriptsize
	\item
\begin{verbatim}
pci_mapreg_map(const struct pci_attach_args *pa, int reg, 
pcireg_t type, int busflags, bus_space_tag_t *tagp, 
bus_space_handle_t *handlep, bus_addr_t *basep, bus_size_t *sizep);
\end{verbatim}

	\normalsize
	\item {\tt pci\_mapreg\_map} creates mapping from physical address present in specified BAR register to kernel virtual address
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Mapping the registers using BAR - adding auxiliary includes}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/pci/faareg.h}
\end{itemize}
\begin{verbatim}
#define FAA_MMREG_BAR   0x10
\end{verbatim}
\begin{itemize}
	\item {\tt src/sys/dev/pci/faavar.h}
\end{itemize}
\begin{verbatim}
struct faa_softc {
        device_t sc_dev;

        bus_space_tag_t sc_regt;
        bus_space_handle_t sc_regh;
        bus_addr_t sc_reg_pa;

};
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mapping the registers using BAR - main driver code}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
static void
faa_attach(device_t parent, device_t self, void *aux)
{
        struct faa_softc *sc = device_private(self);
        const struct pci_attach_args *pa = aux;

        sc->sc_dev = self;

        pci_aprint_devinfo(pa, NULL);

        if (pci_mapreg_map(pa, FAA_MMREG_BAR, PCI_MAPREG_TYPE_MEM, 0, 
            &sc->sc_regt, &sc->sc_regh, &sc->sc_reg_pa, 0) != 0 ) {
            aprint_error_dev(sc->sc_dev, "can't map the BAR\n");
            return;
        }

        aprint_normal_dev(sc->sc_dev, "regs at 0x%08x\n", (uint32_t) sc->sc_reg_pa);
}
\end{lstlisting}
\end{frame}

\subsection{Accessing the hardware registers}

\begin{frame}
\frametitle{Accessing the hardware registers}
\begin{itemize}
	\item The {\tt bus\_space\_read\_*} and {\tt bus\_space\_write\_*} functions are basic methods of reading and writing the hardware registers
	\item {\tt uintX\_t bus\_space\_read\_X(bus\_space\_tag\_t space, bus\_space\_handle\_t handle, bus\_size\_t offset);}
	\item {\tt void bus\_space\_write\_X(bus\_space\_tag\_t space, bus\_space\_handle\_t handle, bus\_size\_t offset, uintX\_t value);}
	\begin{itemize}
		\item {\tt space} - tag describing the bus
		\item {\tt handle} - describes the exact location on the bus where read/write should occur, this handle is obtained by {\tt bus\_space\_map}
		\item {\tt offset} - offset from handle location
		\item The read function returns the data read from the specified location, while write has an argument {\tt value} which should be filled with data to be written
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Variants of bus\_space\_read and bus\_space\_write}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Data & Read function & Write function \\
\hline
\hline
8-bit & bus\_space\_read\_1 & bus\_space\_write\_1 \\
\hline
16-bit & bus\_space\_read\_2 & bus\_space\_write\_2 \\
\hline
32-bit & bus\_space\_read\_4 & bus\_space\_write\_4 \\
\hline
64-bit & bus\_space\_read\_8 & bus\_space\_write\_8 \\
\hline
\end{tabular}
\end{center}
\begin{itemize}
	\item There are many more variants of read and write functions and they are useful in certain situations, see the \href{http://netbsd.gw.com/cgi-bin/man-cgi?bus_space++NetBSD-current}{bus\_space(9)} man page
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Accessing the hardware registers - example}
\begin{itemize}
	\item Create a function that will write a value into the {\tt DATA} register of our device, then read it back and check if the value is the same as written
	\item Define the {\tt DATA} register in the driver
	\item {\tt src/sys/dev/pci/faareg.h}
\end{itemize}
\begin{lstlisting}
#define FAA_DATA                0x8
#define FAA_COMMAND             0x4
#define FAA_COMMAND_STORE_A         __BIT(1)
\end{lstlisting}
\begin{itemize}
	\item Define the new function in main driver code
	\item {\tt static bool faa\_check(struct faa\_softc *sc);}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Accessing the hardware registers - example}
\begin{itemize}
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
static void
faa_attach(device_t parent, device_t self, void *aux)
{
   /* ... */
   if (!faa_check(sc)) {
   		aprint_error_dev(sc->sc_dev, "hardware not responding\n");
        return;
   }
}

static bool
faa_check(struct faa_softc *sc)
{
        uint32_t testval = 0xff11ee22; 
        bus_space_write_4(sc->sc_regt, sc->sc_regh, FAA_COMMAND, FAA_COMMAND_STORE_A);
        bus_space_write_4(sc->sc_regt, sc->sc_regh, FAA_DATA, testval);
        if (bus_space_read_4(sc->sc_regt, sc->sc_regh, FAA_DATA) == testval)
                return true;

        return false;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Accessing the hardware registers - running the example}
\begin{itemize}
	\item Update the kernel binary and run it again
	\item Check the GXemul log
\end{itemize}
\begin{verbatim}
[ faa: COMMAND register (0x4) WRITE value 0x2 ]
[ faa: DATA register (0x8) WRITE value 0xff11ee22 ]
[ faa: DATA register (0x8) READ value 0xff11ee22 ]
\end{verbatim}
\begin{itemize}
	\item GXemul will conveniently display all accesses to our device
	\item The {\tt faa} driver still does attach without error, which means that the check function is working properly
\end{itemize}
\tiny
\begin{verbatim}
faa0 at pci0 dev 12 function 0: Fake Cards Advanced Addition Accelerator (rev. 0x01)
faa0: registers at 0x10110000
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementing addition using the hardware}
\begin{itemize}
	\item The basic principle of device operation should be laid out in the data sheet
	\item We need to implement an algorithm based on this description \hyperlink{faaop}{\beamergotobutton{Jump to device description}}


	\item But first we should define all registers
	\item {\tt src/sys/dev/pci/faareg.h}
\end{itemize}
\begin{lstlisting}
#define FAA_STATUS              0x0
#define FAA_COMMAND             0x4
#define FAA_COMMAND_ADD             __BIT(0)        
#define FAA_COMMAND_STORE_A         __BIT(1)
#define FAA_COMMAND_STORE_B         __BIT(2)
#define FAA_DATA                0x8
#define FAA_RESULT              0xC
\end{lstlisting}

%\begin{itemize}
% \item Writing such an algorithm is often not needed, since the NetBSD kernel already has frameworks for common device types (such as {\tt atabus/wd} for IDE and SATA hard disk controllers, {\tt wsdisplay/wscons} for frame buffers, etc.)
%\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Implementing addition using the hardware}
\begin{itemize}
	\item Add a new function to the main driver code
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
static void
faa_attach(device_t parent, device_t self, void *aux)
{
        /* ... */
        aprint_normal_dev(sc->sc_dev, "just checking: 1 + 2 = %d\n", faa_add(sc, 1, 2));
}

static uint32_t
faa_add(struct faa_softc *sc, uint32_t a, uint32_t b)
{
        bus_space_write_4(sc->sc_regt, sc->sc_regh, FAA_COMMAND, FAA_COMMAND_STORE_A);
        bus_space_write_4(sc->sc_regt, sc->sc_regh, FAA_DATA, a);
        bus_space_write_4(sc->sc_regt, sc->sc_regh, FAA_COMMAND, FAA_COMMAND_STORE_B);
        bus_space_write_4(sc->sc_regt, sc->sc_regh, FAA_DATA, b);
        bus_space_write_4(sc->sc_regt, sc->sc_regh, FAA_COMMAND, FAA_COMMAND_ADD);
        return bus_space_read_4(sc->sc_regt, sc->sc_regh, FAA_RESULT);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Implementing addition using the hardware - running the example}
\begin{itemize}
	\item Update the kernel binary and run it again
	\item Check GXemul log
\end{itemize}
\begin{verbatim}
[ faa: COMMAND register (0x4) WRITE value 0x2 ]
[ faa: DATA register (0x8) WRITE value 0x1 ]
[ faa: COMMAND register (0x4) WRITE value 0x4 ]
[ faa: DATA register (0x8) WRITE value 0x2 ]
[ faa: COMMAND register (0x4) WRITE value 0x1 ]
[ faa: RESULT register (0xC) READ value 0x3 ]
\end{verbatim}
\begin{itemize}
	\item Looks like it worked!
\end{itemize}
\tiny
\begin{verbatim}
faa0 at pci0 dev 12 function 0: Fake Cards Advanced Addition Accelerator (rev. 0x01)
faa0: registers at 0x10110000
faa0: just checking: 1 + 2 = 3
\end{verbatim}
\end{frame}

\section{Interacting with userspace}

\subsection{Device files}

\begin{frame}
\frametitle{The kernel-user space interface}
\begin{itemize}
	\item Now that the core functionality of the kernel driver is working, it should be exposed to user space
	\item The classic UNIX way of interfacing between the kernel and user space is a device file
	\item It's up to the programmer to define the communication protocol - there is no single interfacing method that fits all use cases
	\item In NetBSD device files are created statically ({\tt MAKEDEV} script, manually by using the {\tt mknod} utility)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Operations on device files}
\begin{itemize}
	\scriptsize
	\item {\tt crw-r-----  1 root  wheel  101, 1 Aug 12 21:53 /dev/file}
	\normalsize
	\item The kernel identifies which driver should service the request to this file by using major and minor numbers (101 and 1 in the example above)
	\item The major number identifies the driver
	\item The minor number usually identifies the driver instance, although the driver is free to use it in any other way
	\item System calls: \href{http://netbsd.gw.com/cgi-bin/man-cgi?read++NetBSD-current}{open(2)} and \href{http://netbsd.gw.com/cgi-bin/man-cgi?read++NetBSD-current}{close(2)}, \href{http://netbsd.gw.com/cgi-bin/man-cgi?read++NetBSD-current}{read(2)} and \href{http://netbsd.gw.com/cgi-bin/man-cgi?write++NetBSD-current}{write(2)}, \href{http://netbsd.gw.com/cgi-bin/man-cgi?write++NetBSD-current}{ioctl(2)}, \href{http://netbsd.gw.com/cgi-bin/man-cgi?poll++NetBSD-current}{poll(2)}, \href{http://netbsd.gw.com/cgi-bin/man-cgi?write++NetBSD-current}{mmap(2)} and more\dots
	\item Any mix of the above system calls might be used to interface between the kernel and user space
	\item We'll implement an {\tt ioctl(2)}-based communication mechanism

\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding {\tt cdevsw}}
\begin{itemize}
	\item {\tt cdevsw} is used to decide which operation on the character device file calls which driver function (there's also {\tt bdevsw} for block devices, but we won't use it in this example)
	\item Not all calls have to be implemented, although some device layers define a set of calls that a driver must implement
	\item For example disk drivers must implement open, close, read, write and ioctl
\end{itemize}
\begin{itemize}
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
dev_type_open(faaopen);
dev_type_close(faaclose);
dev_type_ioctl(faaioctl);

const struct cdevsw faa_cdevsw = {
        faaopen, faaclose, noread, nowrite, faaioctl,
        nostop, notty, nopoll, nommap, nokqfilter, D_OTHER
};
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
\frametitle{Implemeting the {\tt cdevsw} operations - open / close}
\begin{itemize}
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
int
faaopen(dev_t dev, int flags, int mode, struct lwp *l)
{
        struct faa_softc *sc;
        sc = device_lookup_private(&faa_cd, minor(dev));

        if (sc == NULL)
                return ENXIO;
        if (sc->sc_flags & FAA_OPEN)
                return EBUSY;

        sc->sc_flags |= FAA_OPEN;
        return 0;
}
int
faaclose(dev_t dev, int flag, int mode, struct lwp *l)
{
        struct faa_softc *sc;
        sc = device_lookup_private(&faa_cd, minor(dev));

        if (sc->sc_flags & FAA_OPEN)
                sc->sc_flags =~ FAA_OPEN;

        return 0;
}
\end{lstlisting}
\end{frame}

\subsection{Using ioctls}

\begin{frame}[fragile]
\frametitle{Defining the {\tt ioctl}s}
\begin{itemize}
	\item {\tt ioctl(2)} can be used to call kernel-level functions and exchange data between the kernel and user space
	\item The classic way of passing data is by using structures, their definitions are shared between the kernel and user space code
	\item The driver might support more than one {\tt ioctl}, the {\tt \_IO*} macros are used to define the operation and associated structure used to exchange data
	\begin{itemize}

		\item {\tt \#define DRIVERIO\_IOCTLNAME	\_XXX(group, ioctl\_number, data structure)}
		\item Where {\tt XXX} can be {\tt IO}, {\tt IOR}, {\tt IOW}, {\tt IOWR}
	\end{itemize}
\end{itemize}

\begin{itemize}
\item {\tt src/sys/dev/pci/faaio.h}
\end{itemize}
\begin{lstlisting}
#include <sys/ioccom.h>
                     
#define FAAIO_ADD	_IOWR(0, 1, struct faaio_add)

struct faaio_add {
    uint32_t a;
    uint32_t b;
    uint32_t *result;
};
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Implemeting the {\tt cdevsw} operations - {\tt ioctl}}
\begin{itemize}
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
int
faaioctl(dev_t dev, u_long cmd, void *data, int flag, struct lwp *l)
{
        struct faa_softc *sc = device_lookup_private(&faa_cd, minor(dev));
        int err;

        switch (cmd) {
        case FAAIO_ADD:
                err = faaioctl_add(sc, (struct faaio_add *) data);
                break;
        default:
                err = EINVAL;
                break;
        }
        return(err);
}
static int
faaioctl_add(struct faa_softc *sc, struct faaio_add *data)
{
        uint32_t result; int err;

        aprint_normal_dev(sc->sc_dev, "got ioctl with a %d, b %d\n",
            data->a, data->b);

        result = faa_add(sc, data->a, data->b);
        err = copyout(&result, data->result, sizeof(uint32_t));
        return err;
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Defining device major number}
\begin{itemize}
	\item Device major numbers for hardware drivers are usually defined in a per-port manner\footnote{It's also possible to define a major in a machine-independent way in {\tt src/sys/conf/majors}}
	\item {\tt src/sys/arch/\$PORTNAME/conf/majors.\$PORTNAME}
	\item {\tt src/sys/arch/cobalt/conf/majors.cobalt}
	\item The following defines a new character device file called {\tt /dev/faa*} with major number 101, but only if the {\tt faa} driver is included in the kernel (last argument)
	\item {\tt device-major faa char 101 faa}
	\item The {\tt mknod} utility can be used to create the device file manually
	\item {\tt mknod /dev/faa0 c faa 0}

\end{itemize}
\end{frame}

\subsection{An example user space program}

\begin{frame}[fragile]
\frametitle{An example user space program - source}
\begin{itemize}
	\item The example program will open the device file and call {\tt ioctl(2)} on it
\end{itemize}
\begin{lstlisting}
void add(int, uint32_t, uint32_t);

static const char* faa_device = "/dev/faa0";

int
main(int argc, char *argv[])
{
        int devfd;

        if (argc != 3) {
                printf("usage: %s a b\n", argv[0]);
                return 1;
        }
        if ( (devfd = open(faa_device, O_RDWR)) == -1) {
                perror("can't open device file");
                return 1;
        }

        add(devfd, atoi(argv[1]), atoi(argv[2]));

        close(devfd);
        return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{An example user space program - source}
\begin{lstlisting}
void
add(int devfd, uint32_t a, uint32_t b)
{
        struct faaio_add faaio;
        uint32_t result = 0;

        faaio.result = &result;
        faaio.a = a;
        faaio.b = b;

        if (ioctl(devfd, FAAIO_ADD, &faaio) == -1) {
                perror("ioctl failed");
        }
        printf("%d\n", result);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{An example user space program - running it}
\begin{verbatim}
# make
cc -o aaa_add aaa_add.c
# ./aaa_add 3 7
faa0: got ioctl with a 3, b 7
10
\end{verbatim}
\begin{itemize}
	\item The program is successfully accessing the {\tt faa} driver through the {\tt ioctl}	
	\item The {\tt faa0:...} line is a kernel message, normally only seen on the console terminal
\end{itemize}
\end{frame}

\section{Summary}

\begin{frame}
\frametitle{What next?}

\begin{itemize}
	\item Get the EuroBSDcon version of this tutorial, download the source code and materials for this tutorial
	\begin{itemize}
		\item {\small\url{https://github.com/rkujawa/busspace-tutorial}}
		\item {\small\url{https://github.com/rkujawa/gxemul-tutorial}}
	\end{itemize} 
	
	\item Documentation, articles:
	\begin{itemize}
		\item \href{http://www.netbsd.org/docs/kernel/bus_dma.pdf}{A Machine-Independent DMA Framework for NetBSD, Jason R. Thorpe}
		\item \href{ftp://ftp.netbsd.org/pub/NetBSD/misc/ddwg/NetBSD-driver_writing-1.0.1e.pdf}{Writing Drivers for NetBSD, Jochen Kunz}
		\item \href{http://www.netbsd.org/docs/kernel/pseudo/}{NetBSD Documentation: Writing a pseudo device}
		\item \href{http://netbsd.gw.com/cgi-bin/man-cgi?autoconf+9+NetBSD-current}{autoconf(9)}, 
			\href{http://netbsd.gw.com/cgi-bin/man-cgi?bus_space+9+NetBSD-current}{bus\_space(9)},
			\href{http://netbsd.gw.com/cgi-bin/man-cgi?bus_dma+9+NetBSD-current}{bus\_dma(9)},
			\href{http://netbsd.gw.com/cgi-bin/man-cgi?driver+9+NetBSD-current}{driver(9)}, 
			\href{http://netbsd.gw.com/cgi-bin/man-cgi?pci+9+NetBSD-current}{pci(9)}
			{\tt man} pages, etc.
	\end{itemize}
	\item Example source code of drivers:
	\begin{itemize}
		\item {\tt tdvfb}, {\tt voodoofb} are fairly good frame buffer driver examples with documentation publicly available.
		\item {\tt etsec} is a nice example of a more complicated network interface driver
	\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Questions?}

\begin{itemize}
	\item Do you have any questions?
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The End\ldots}
\vspace*{-0.8cm}
\begin{center}
\includegraphics[scale=0.5]{NetBSD.png}

Thank you!
\end{center}
\end{frame}

 
\end{document}
