\documentclass[dvipsnames,table]{beamer}

\usetheme{Frankfurt}
\usecolortheme{orchid}

\usepackage{listings}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{wasysym}
\usepackage[normalem]{ulem}

\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{caption}[numbered]
\setbeamerfont{caption}{size=\scriptsize}
\setbeamercolor{framenote}{bg=NetBSD-orange!25}
\setbeamercolor{rednote}{bg=Red!25}
\setbeamercolor{palette primary}{use=structure,fg=white,bg=NetBSD-orange}
\setbeamercolor{palette secondary}{use=structure,fg=white,bg=NetBSD-orange2}

\setbeamertemplate{itemize item}{\scriptsize\raise1pt\hbox{\donotcoloroutermaths$\blacktriangleright$}}
\setbeamertemplate{itemize subitem}{\tiny\raise1pt\hbox{\donotcoloroutermaths$\bullet$}}
\setbeamertemplate{itemize subsubitem}{\tiny\raise1pt\hbox{\donotcoloroutermaths{--}}}

\setbeamertemplate{enumerate item}{\insertenumlabel.}
\setbeamertemplate{enumerate subitem}{\insertenumlabel.\insertsubenumlabel}
\setbeamertemplate{enumerate subsubitem}{\insertenumlabel.\insertsubenumlabel.\insertsubsubenumlabel}
\setbeamertemplate{enumerate mini template}{\insertenumlabel}

\setbeamercolor{itemize item}{fg=NetBSD-orange, bg=NetBSD-orange}
\setbeamercolor{itemize subitem}{fg=NetBSD-orange, bg=NetBSD-orange}
\setbeamercolor{itemize subsubitem}{fg=NetBSD-orange, bg=NetBSD-orange}

\setbeamercolor{section number projected}{fg=white,bg=NetBSD-orange}
\setbeamercolor{subsection number projected}{fg=white,bg=NetBSD-orange}
\setbeamertemplate{section in toc}[circle]
\setbeamertemplate{subsection in toc}[square]

\definecolor{NetBSD-orange}{RGB}{242,103,17}
\definecolor{NetBSD-orange2}{RGB}{177,76,12}
\hypersetup{colorlinks=true,linkcolor=white,urlcolor=NetBSD-orange}

\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.2}

\newcommand{\nbsdcolor}[1] {
	{\color{NetBSD-orange} #1}
}

\lstset{
   language=C,
   basicstyle=\tiny,
   breaklines=true,
   escapechar=\@,
   commentstyle=\color{NetBSD-orange}
}

\title{Writing the NetBSD drivers\\with bus\_space(9) framework}

\author{Radoslaw Kujawa -- rkujawa@NetBSD.org}

\institute{The NetBSD Foundation}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Table of Contents}
{
\hypersetup{colorlinks=true,linkcolor=black,urlcolor=NetBSD-orange}
\tableofcontents
}
\end{frame}

\section{Introduction}
\subsection{Why was this tutorial created?}

\begin{frame}
\frametitle{Why was this tutorial created?}
\begin{itemize}
	\item Introductory-level documentation is scarce
	\item Writing the device drivers is often considered black magic
	\item Reading the {\tt man} pages won't give you the big picture
	\item BSD systems are always in need of new drivers
	\item Device drivers are fun {\Large \smiley}
\end{itemize}
\end{frame}

\subsection{What won't be covered here?}

\begin{frame}
\frametitle{What won't be covered here?}
We don't have much time, so several \sout{advanced} topics were omitted:
\begin{itemize}
	\item Interrupt handling
	\item Direct Memory Access and {\tt bus\_dma} framework
	\item Power management
	\item Driver detachment
	\item Drivers as kernel modules
	\item Examples for buses other than PCI
	\item Pretty much everything else...
\end{itemize}
However, once you finish this tutorial, you should be able to purse this knowledge yourself.
\end{frame}

\subsection{What is a driver anyway?}

\begin{frame}
\frametitle{What is a driver anyway?}
\begin{itemize}
	\item Interface between user space and hardware, implemented as a part of the kernel
	\item The NetBSD drivers are written mostly in C
	\item Sometimes they have machine dependent assembler parts, but this is a rare case
\end{itemize}
\end{frame}

\subsection{What do you need to write a driver?}

\begin{frame}
\frametitle{What do you need to write a driver?}
\begin{itemize}
	\item C programming skills
	\item Hardware documentation or ability to reverse engineer the hardware
	\item Reference driver implementation will help but is not essential
	\item The NetBSD installation and kernel source or cross-build environment (the latter is usually preferred for development of drivers)
	\item A lot of time, coffee and patience {\Large \smiley}
\end{itemize}
\end{frame}

\section{The NetBSD driver model}
\subsection{The NetBSD kernel basics}

\begin{frame}
\frametitle{The NetBSD kernel basics}
\begin{itemize}
	\item The NetBSD has a classic monolithic UNIX-like kernel - all drivers are running in the same address space
	\item Thanks to above, communication between drivers and other kernel layers is simple
	\item However, it also means that one badly written driver can affect the whole kernel
	\item Numerous in-kernel frameworks standardise the way drivers are written ({\tt bus\_space}, {\tt autoconf} etc.) 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The NetBSD source directory structure}
\begin{itemize}
	\item We'll only cover parts interesting for a device driver programmer
	\item {\tt src/sys/} - kernel source directory
	\item {\tt src/sys/dev/} - machine-independent device drivers
	\item {\tt src/sys/arch/} - port-specific or architecture-specific parts (like low-level system initialisation procedures or machine-dependent drivers)
	\item {\tt src/sys/arch/\$PORTNAME/conf/} - kernel configuration files for a given port

\end{itemize}
\end{frame}

\subsection{Kernel autoconfiguration framework}

\begin{frame}
\frametitle{Kernel autoconfiguration framework - autoconf(9)}
\begin{itemize}
	\item Autoconfiguration is the process of matching hardware devices with an
     appropriate device driver
    \item Kernel message buffer (dmesg) contains information about autoconfiguration of devices
    \item {\tt driver0 at bus0: Foo hardware} 
    \begin{itemize}
    	\item Instance 0 of the driver has attached to instance 0 of particular bus
		\item Such message often carries additional bus-specific information about exact location of the device (like device and function number on the PCI bus)
	\end{itemize}
    \item {\tt driver0: some message}
    \begin{itemize}
    	\item Additional information about the driver state or device configuration
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Autoconfiguration as seen in dmesg}
\tiny
\begin{verbatim}
NetBSD 6.99.12 (GENERIC) #7: Fri Oct  5 18:43:21 CEST 2012
        rkujawa@saiko.local:/Users/rkujawa/netbsd-eurobsdcon2012/src/sys/arch/cobalt/compile/obj/GENERIC
Cobalt Qube 2
total memory = 32768 KB
avail memory = 27380 KB
mainbus0 (root)
com0 at mainbus0 addr 0x1c800000 level 3: ns16550a, working fifo
com0: console
cpu0 at mainbus0: QED RM5200 CPU (0x28a0) Rev. 10.0 with built-in FPU Rev. 1.0
cpu0: 48 TLB entries, 256MB max page size
cpu0: 32KB/32B 2-way set-associative L1 instruction cache
cpu0: 32KB/32B 2-way set-associative write-back L1 data cache
mcclock0 at mainbus0 addr 0x10000070: mc146818 compatible time-of-day clock
panel0 at mainbus0 addr 0x1f000000
gt0 at mainbus0 addr 0x14000000
pci0 at gt0
pchb0 at pci0 dev 0 function 0: Galileo GT-64011 System Controller, rev 1
pcib0 at pci0 dev 9 function 0
pcib0: VIA Technologies VT82C586 PCI-ISA Bridge, rev 57
viaide0 at pci0 dev 9 function 1
viaide0: VIA Technologies VT82C586 (Apollo VP) ATA33 controller
viaide0: primary channel interrupting at irq 14
atabus0 at viaide0 channel 0
viaide0: secondary channel interrupting at irq 15
atabus1 at viaide0 channel 1
wd0 at atabus0 drive 0
wd0: <netbsd-cobalt.img>
wd0: 750 MB, 1524 cyl, 16 head, 63 sec, 512 bytes/sect x 1536192 sectors\end{verbatim}
\end{frame}

\begin{frame}
\frametitle{Autoconfiguration as seen in dmesg}
\begin{center}
\includegraphics[scale=0.4]{img_cobaltdevices.png}
\end{center}
\end{frame}

\begin{frame}
\frametitle{The bus\_space(9) framework}
\begin{itemize}
	\item "The goal of the bus\_space functions is to allow a single
     driver source file to manipulate a set of devices on different system
     architectures, and to allow a single driver object file to manipulate a
     set of devices on multiple bus types on a single architecture."
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Machine independent drivers}

\begin{itemize}
	\item If possible drivers should work on any hardware platform
	\item High quality, machine-independent (MI) drivers are an important factor that adds to the NetBSD portability
	\item Some drivers are completely MI, some have MD or bus dependent attachments and some are completely MD
	\begin{itemize}
		\item Driver for a typical PCI card will be completely MI
		\item Driver for a SoC components will usually be completely MD
	\end{itemize}
	\item The {\tt bus\_space} abstractions helps achieving portability, transparently handling endianness issues and hiding bus implementation details from the device driver
	\item Even if we have MI drivers, writing the drivers is always significant part of effort needed to port the NetBSD to a new hardware
\end{itemize}
\end{frame}

%\subsection{Skeleton of the driver}

\section{Example driver from scratch}

\subsection{Development environment}

\begin{frame}
\frametitle{Development environment}
\begin{itemize}
	\item Out of scope of this course, but very well documented
	\item Cross compiling is an easy task with the {\tt build.sh} script
	\item Described in \href{http://www.netbsd.org/docs/guide/en/part-compile.html}{Part V of the NetBSD Guide}
	\item Check out the NetBSD sources
	\item {\tt \$ build.sh -m cobalt tools} will build compiler, assembler, linker, etc. for cobalt port
	\item {\tt \$ build.sh -m cobalt kernel=GENERIC} will build GENERIC kernel for cobalt
	\item Pass {\tt -u} parameter to {\tt build.sh} to update (won't rebuilding everything)
\end{itemize}
\end{frame}

\subsection{Quick introduction to {\tt GXemul}}

\begin{frame}
\frametitle{Quick introduction to {\tt GXemul}}
\begin{itemize}
	\item A framework for full-system computer architecture emulation, excellent for educational purposes
	\item Capable of emulating several real machines supported by the NetBSD
	\item We'll emulate a \href{http://en.wikipedia.org/wiki/Cobalt_Qube}{Cobalt}, MIPS-based micro server with PCI bus
	\item I've modified {\tt GXemul} and implemented an emulation of additional PCI device
	\item It will be used to show (almost) a real-life example of driver development
\end{itemize}
\end{frame}

\subsection{Our hardware - a fake PCI card}

\begin{frame}
\frametitle{Our hardware - functional description}
\begin{itemize}
	\item Business applications often use arithmetic operations like addition
	\item Fake Cards Inc. responded to market needs and created a new product, Advanced Addition Accelerator
	\item Pointy Haired Bosses will certainly buy it to accelerate their business applications, so let's create a driver for the NetBSD!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Our hardware - technical details}
\begin{itemize}
	\item Implemented as a PCI card
	\item Has just two registers in PCI memory space
\end{itemize}
\end{frame}

\subsection{Adding a new driver to the NetBSD kernel}

\subsection{Matching the PCI device}

\begin{frame}[fragile]
\frametitle{Modifying the PCI device database}
\begin{verbatim}
unmatched vendor 0xfabc product 0x0001 (Co-processor 
processor, revision 0x01) at pci0 dev 12 function 0 
not configured
\end{verbatim}
\begin{itemize}
	\item Kernel does not know anything about this vendor and device
	\item Add it to PCI device database - {\tt src/sys/dev/pci/pcidevs}
	\item {\tt vendor VENDORNAME 0xVENDORID Long Vendor Name}
	\item {\tt product VENDORNAME PRODUCTNAME 0xPRODUCTID	Long Product Name}
	\item To regenerate pcidevs*.h run {\tt awk -f devlist2h.awk pcidevs} or
{\tt Makefile.pcidevs} if you're on the NetBSD
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Modifying the PCI device database - example}
\scriptsize
\begin{verbatim}
--- pcidevs	29 Sep 2012 10:26:14 -0000	1.1139
+++ pcidevs	5 Oct 2012 08:52:59 -0000
@@ -669,6 +669,7 @@
 vendor CHRYSALIS	0xcafe	Chrysalis-ITS
 vendor MIDDLE_DIGITAL	0xdeaf	Middle Digital
 vendor ARC		0xedd8	ARC Logic
+vendor FAKECARDS	0xfabc	Fake Cards
 vendor INVALID		0xffff	INVALID VENDOR ID
 
 /*
@@ -2120,6 +2121,9 @@
 /* Eumitcom products */
 product EUMITCOM WL11000P	0x1100	WL11000P PCI WaveLAN/IEEE 802.11
 
+/* FakeCards products */
+product FAKECARDS AAA		0x0001	Advanced Addition Accelerator
+
 /* O2 Micro */
 product O2MICRO 00F7		0x00f7	Integrated OHCI IEEE 1394 Host Controller
 product O2MICRO OZ6729		0x6729	OZ6729 PCI-PCMCIA Bridge
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Modifying the PCI device database - example}
\begin{verbatim}
Fake Cards Advanced Addition Accelerator (Co-processor 
processor, revision 0x01) at pci0 dev 12 function 0 
not configured
\end{verbatim}
\begin{itemize}
	\item Now the kernel knows the vendor and product ID
	\item But there's still no driver for this device
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adding the new PCI driver}
\begin{itemize}
	\item Choose a name - short, easy to remember, avoid numbers
	\begin{itemize}
		\item {\tt faa} looks like a good name, but you can choose any name you like
	\end{itemize}
	\item Create a set of new files in {\tt src/sys/dev/pci}
	\begin{itemize}
		\item {\tt faa.c} - main driver code
		\item {\tt faareg.h} - register definitions\footnote{Might not exist if the driver is only a simple passthrough from specific bus to other MI driver.}
		\item {\tt faavar.h} - driver structures and functions used in other parts of the kernel\footnote{Omitted if not needed.}
	\end{itemize}
	\item Modify driver definitions
	\begin{itemize}
		\item {\tt src/sys/dev/pci/files.pci}
		\item {\tt src/sys/dev/DEVNAMES}
	\end{itemize}
	\item Add the driver to kernel configuration file - {\tt src/sys/arch/\$PORTNAME/conf/GENERIC}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adding the new PCI driver - main driver}
\begin{itemize}
	\item Kernel includes are at the beginning, followed by machine-specific and bus-specific includes
	\item Should also include {\tt faareg.h} and {\tt faavar.h} files
	\item Minimal driver needs just two functions
	\begin{itemize}
		\item {\tt faa\_match} (or {\tt faa\_probe} for some buses)
		\item {\tt faa\_attach}
	\end{itemize}
	\item {\tt CFATTACH\_DECL\_NEW} macro plugs above functions into autoconf(9) mechanism
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adding the new PCI driver - main driver}
\begin{itemize}
	\item {\tt static int faa\_match(device\_t parent, cfdata\_t match, void *aux);}	
	\begin{itemize}
		\item Check if the driver should attach to a given device (for example in case of PCI bus, it will be used to check vendor and product ID)
		\item {\tt parent} - pointer to parent's driver device structure
		\item {\tt match} - pointer to structure describing how... TODO
		\item {\tt aux} - despite the name most important argument...
	\end{itemize}
	\item {\tt static void faa\_attach(device\_t parent, device\_t self, void *aux);}
	\begin{itemize}
		\item Attach the driver to a given device
		\item {\tt parent} - same as with match function
		\item {\tt self} - pointer to driver's device structure
		\item {\tt aux} - same as with match function
	\end{itemize}

	\item See definitions of these functions in the \href{http://netbsd.gw.com/cgi-bin/man-cgi?driver+9+NetBSD-current}{driver(9)} man page.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adding the new PCI driver - main driver cont'd}
\begin{itemize}
	\item {\tt CFATTACH\_DECL\_NEW(faa, sizeof(struct faa\_softc),    faa\_match, faa\_attach, NULL, NULL);}
	\begin{itemize}
		\item driver name
		\item size of softc structure containing state of driver's instance
		\item match/probe function
		\item attach function
		\item detach TODO
		\item activate TODO
	\end{itemize}
	\item \_NEW name is not fortunate
	\item This variant was introduced recently and isn't documented well
\end{itemize}
\end{frame}




\begin{frame}[fragile]
\frametitle{Adding the new PCI driver - main driver example}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD$");
#include <sys/param.h>
#include <sys/device.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/faareg.h>
#include <dev/pci/faavar.h>

static int      faa_match(device_t, cfdata_t, void *);
static void     faa_attach(device_t, device_t, void *);

CFATTACH_DECL_NEW(faa, sizeof(struct faa_softc),
    faa_match, faa_attach, NULL, NULL);

static int
faa_match(device_t parent, cfdata_t match, void *aux)
{
        return 0;
}

static void
faa_attach(device_t parent, device_t self, void *aux)
{ 
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding the new PCI driver - auxiliary includes}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/pci/faareg.h}
\end{itemize}
\begin{lstlisting}
#ifndef FAAREG_H
#define FAAREG_H
/* 
 * Registers are defined using preprocessor:
 * #define FAA_REGNAME	0x0
 * We'll add them later, let's leave it empty for now.
 */
#endif /* FAAREG_H */
\end{lstlisting}
\begin{itemize}
	\item {\tt src/sys/dev/pci/faavar.h}
\end{itemize}
\begin{lstlisting}
#ifndef FAAVAR_H
#define FAAVAR_H

/* sc_dev is an absolute minimum, we'll add more later */
struct faa_softc {
        device_t sc_dev;
};
#endif /* FAAVAR_H */
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
\frametitle{Adding the new PCI driver - registering the driver}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/pci/files.pci}
\end{itemize}
\begin{verbatim}
--- pci/files.pci	2 Aug 2012 00:17:44 -0000	1.360
+++ pci/files.pci	6 Oct 2012 19:59:10 -0000
@@ -1122,3 +1122,9 @@
 device	tdvfb: wsemuldisplaydev, rasops8, vcons, videomode
 attach	tdvfb at pci
 file	dev/pci/tdvfb.c		tdvfb	
+
+# FakeCards Advanced Addition Accelerator
+device	faa
+attach	faa at pci
+file	dev/pci/faa.c		faa	
+
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding the new PCI driver - registering the driver}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/DEVNAMES}
\end{itemize}
\begin{verbatim}
--- DEVNAMES	1 Sep 2012 11:19:58 -0000	1.279
+++ DEVNAMES	6 Oct 2012 19:59:06 -0000
@@ -436,6 +436,7 @@
 ex			MI
 exphy			MI
 ezload			MI		Attribute
+faa			MI
 fb			luna68k
 fb			news68k
 fb			newsmips
\end{verbatim}
\end{frame}


\begin{frame}[fragile]
\frametitle{Adding the new PCI driver to the kernel configuration}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/arch/cobalt/conf/GENERIC}
\end{itemize}
\begin{verbatim}
--- GENERIC	10 Mar 2012 21:51:50 -0000	1.134
+++ GENERIC	6 Oct 2012 20:12:37 -0000
@@ -302,6 +302,9 @@
 #fms*		at pci? dev ? function ?	# Forte Media FM801
 #sv*		at pci? dev ? function ?	# S3 SonicVibes
 
+# Fake Cards Advanced Addition Accelerator
+faa*		at pci? dev ? function ?
+
 # Audio support
 #audio*		at audiobus?
\end{verbatim}
\begin{itemize}
	\item An instance of {\tt faa} may be attached to any PCI device, any function
	\item Driver's match function will check if the driver is able to work with given device
	\item Exact position of rule in the configuration file is not important in this case
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Adding the new PCI driver - example}
\begin{itemize}
	\item The driver should compile now
	\item But the kernel still won't "find" the device
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Matching the PCI device}
\begin{itemize}
	\item Modify the {\tt faa\_match} function to match the specified PCI device
	\item Use {\tt PCI\_VENDOR} and {\tt PCI\_PRODUCT} macros to obtain the IDs
\end{itemize}
\scriptsize
\begin{lstlisting}
static int
faa_match(device_t parent, cfdata_t match, void *aux)
{
        const struct pci_attach_args *pa = (const struct pci_attach_args *)aux;

        if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_FAKECARDS) 
            && (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_FAKECARDS_AAA))
                return 1;

        return 0;
}
\end{lstlisting}
\end{frame}

\subsection{Attaching to the PCI device}

\begin{frame}[fragile]
\frametitle{Attaching to the PCI device}
\begin{verbatim}
faa0 at pci0 dev 12 function 0
\end{verbatim}
\begin{itemize}
	\item The driver has successfully matched and attached to PCI device but still is doing nothing useful
	\item Let's fill attach function and actually program the hardware
\end{itemize}
\end{frame}

\subsection{Variable types used with {\tt bus\_space}}

\begin{frame}
\frametitle{Variable types used with {\tt bus\_space}}

\begin{itemize}
         \item {\tt bus\_space\_tag\_t} -- type used to describe a particular bus, usually passed to driver from MI bus structures
         \item {\tt bus\_space\_handle\_t} --  used to describe a mapped range of bus space, usually created with {\tt bus\_space\_map()} function
         \item {\tt bus\_addr\_t} -- address on the bus
         \item {\tt bus\_size\_t} -- an amount of space on the bus
         \item Contents of these types are MD, so avoid modifying from within driver\footnote{although you'll often have to use {\tt bus\_size\_t}}
\end{itemize}
\end{frame}


\subsection{Mapping the hardware resources}

\begin{frame}
\frametitle{Why do we need to "map" the resources?}
\begin{itemize}
	\item In a memory-protected environment like the NetBSD one cannot directly access the physical addresses
	\item The kernel has its own virtual address space
    \item Physical space can be made visible in kernel virtual address space through process of mapping
    \item It's a machine-dependent process but it's also conveniently hidden from the programmer by bus\_space framework
    \item "Bus space must be mapped before it can be used, and should be unmapped
     when it is no longer needed."
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Mapping the hardware resources}

\begin{itemize}
	\item Generic bus\_space(9) way to map space
\end{itemize}

\begin{verbatim}
bus_space_map(bus_space_tag_t space, bus_addr_t address, 
bus_size_t size, int flags, bus_space_handle_t  *handlep);
\end{verbatim}

\begin{itemize}
	\item The {\tt bus\_space\_map} creates mapping from physical address to kernel virtual address
    \item {\tt space} -- represents bus on which the mapping will be created
    \item {\tt address} -- typically represents physical address for which mapping will be created
	\item {\tt size} -- describes amount of bus space to be mapped
	\item {\tt handlep} -- pointer to mapped space (after successful mapping)
    \item Separate space and address
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mapping the hardware resources}

\begin{itemize}
	\item PCI-specific way to map space
\end{itemize}

\begin{verbatim}
pci_mapreg_map(const struct pci_attach_args *pa, int reg, 
pcireg_t type, int busflags, bus_space_tag_t *tagp, 
bus_space_handle_t *handlep, bus_addr_t *basep, 
bus_size_t *sizep);
\end{verbatim}

\begin{itemize}
	\item The {\tt pci\_mapreg\_map} creates mapping from physical address present in specified BAR register to kernel virtual address
    \item {\tt pa} --
    \item {\tt reg} -- 
   	\item {\tt type} --
	\item {\tt busflags} -- 
	\item {\tt tagp} -- 
	\item {\tt handlep} -- pointer to a mapped space
	\item {\tt basep} -- 
	\item {\tt sizep} -- 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mapping the registers using BAR - filling auxiliary includes}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/pci/faareg.h}
\end{itemize}
\begin{verbatim}
#define FAA_MMREG_BAR   0x10
\end{verbatim}
\begin{itemize}
	\item {\tt src/sys/dev/pci/faavar.h}
\end{itemize}
\begin{verbatim}
struct faa_softc {
        device_t sc_dev;

        bus_space_tag_t sc_regt;
        bus_space_handle_t sc_regh;
        bus_addr_t sc_reg_pa;

};
\end{verbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mapping the registers using BAR - main driver code}
\scriptsize
\begin{itemize}
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
static void
faa_attach(device_t parent, device_t self, void *aux)
{
        struct faa_softc *sc = device_private(self);
        const struct pci_attach_args *pa = aux;

        sc->sc_dev = self;

        pci_aprint_devinfo(pa, NULL);

        if (pci_mapreg_map(pa, FAA_MMREG_BAR, PCI_MAPREG_TYPE_MEM, 0, &sc->sc_regt, &sc->sc_regh, &sc->sc_reg_pa, 0) != 0 ) {
            aprint_error_dev(sc->sc_dev, "can't map\n");
            return;
        }

        aprint_normal_dev(sc->sc_dev, "regs at 0x%08x\n", (uint32_t) sc->sc_reg_pa);
}
\end{lstlisting}
\end{frame}

\subsection{Accessing the hardware registers}

\begin{frame}
\frametitle{Accessing the hardware registers}
\begin{itemize}
	\item The {\tt bus\_space\_read\_*} and {\tt bus\_space\_write\_*} functions are basic methods of reading and writing the hardware registers
	\item {\tt uintX\_t bus\_space\_read\_X(bus\_space\_tag\_t space, bus\_space\_handle\_t handle, bus\_size\_t offset);}
	\item {\tt void bus\_space\_write\_X(bus\_space\_tag\_t space, bus\_space\_handle\_t handle, bus\_size\_t offset, uintX\_t value);}
	\begin{itemize}
		\item {\tt space} - tag describing the bus
		\item {\tt handle} - describes the exact location on bus where read/write should occur, this handle is obtained by {\tt bus\_space\_map}
		\item {\tt offset} - offset from handle location
		\item Read function returns the data read from specified location, while write has argument {\tt value} which should be filled with data to be written
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Variants of bus\_space\_read and bus\_space\_write}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Data & Read function & Write function \\
\hline
\hline
8-bit & bus\_space\_read\_1 & bus\_space\_write\_1 \\
\hline
16-bit & bus\_space\_read\_2 & bus\_space\_write\_2 \\
\hline
32-bit & bus\_space\_read\_4 & bus\_space\_write\_4 \\
\hline
64-bit & bus\_space\_read\_8 & bus\_space\_write\_8 \\
\hline
\end{tabular}
\end{center}
\begin{itemize}
	\item There are many more variants of read and write functions and they are useful in certain situations, see the \href{http://netbsd.gw.com/cgi-bin/man-cgi?bus_space++NetBSD-current}{bus\_space(9)} man page
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Accessing the hardware registers - example}
\begin{itemize}
	\item Create function that will write a value into {\tt DATA} register of our device, then read it back and check if the value is the same as written
	\item Define {\tt DATA} register in the driver
	\item {\tt src/sys/dev/pci/faareg.h}
\end{itemize}
\begin{lstlisting}
#define FAA_DATA	0x8
\end{lstlisting}
\begin{itemize}
	\item Define the new function in main driver code
	\item {\tt static bool faa\_check(faa\_softc *sc);}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Accessing the hardware registers - example}
\begin{itemize}
	\item {\tt src/sys/dev/pci/faa.c}
\end{itemize}
\begin{lstlisting}
static void
faa_attach(device_t parent, device_t self, void *aux)
{
   /* ... */
   if (!faa_check(sc)) {
   		aprint_error_dev(sc->sc_dev, "hardware not responding\n");
        return;
   }
}

bool
faa_check(faa_softc *sc) 
{
        uint32_t testval = 0xff11ee22
        bus_space_write_4(sc->sc_regt, sc->sc_regh, FAA_DATA, testval);
        if (bus_space_read_4(sc->sc_regt, sc->sc_regh, FAA_DATA) == testval)
                return true;

        return false;
}
\end{lstlisting}
\end{frame}

%\subsection{Testing}

%\section{Interacting with the user space}
%\subsection{Device files}
%\subsection{Utilising ioctls}
%\subsection{Example user space program}

\section{A few tips}

\subsection{Avoiding common pitfalls}

\begin{frame}
\frametitle{Avoiding common pitfalls}

\begin{itemize}
	\item Always free resources allocated in {\tt match} or {\tt probe} function
	\item Always use {\tt bus\_space} methods, don't access the hardware using pointer dereference!
	\item If possible test on more than one hardware architecture, some bugs may surface
\end{itemize}
\end{frame}

\subsection{Basic driver debugging}

\begin{frame}
\frametitle{Basic driver debugging} 
\begin{itemize}
	\item Use {\tt aprint\_debug} to print debug-level messages on console and log them (enabled by passing {\tt AB\_DEBUG} from boot loader)
	\item Use built-in DDB debugger
	\begin{itemize}
			\item Enabled by kernel option {\tt DDB}
			\item Kernel panic will start DDB if {\tt DDB\_ONPANIC=1} kernel option is specified or {\tt ddb.onpanic} sysctl is set to 1.
			\item {\tt \# sysctl -w kern.panic\_now=1} to trigger panic manually ({\tt DIAGNOSTIC} option)
	\end{itemize}	
	\item Remote debugging is possible on some ports
	\begin{itemize}
			\item With KGDB through serial port
			\item With IPKDB through network
	\end{itemize}	
\end{itemize}
\end{frame}

\section{Summary}
\subsection{The end}

\begin{frame}
\frametitle{Further reading}
\begin{itemize}
	\item Documentation, articles:
	\begin{itemize}
		\item A Machine-Independent DMA Framework for NetBSD, Jason R. Thorpe
		\item Writing Drivers for NetBSD, Jochen Kunz
		\item NetBSD Documentation: Writing a pseudo device
		\item autoconf(9), bus\_space(9), bus\_dma(9), driver(9), pci(9) {\tt man} pages, etc.
	\end{itemize}
	\item Source code of the drivers:
	\begin{itemize}
		\item {\tt tdvfb}, {\tt voodoofb} are fairly good examples with documentation publicly available.
	\end{itemize}
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Get the source code}

\begin{itemize}
	\item Download the source code and materials for this tutorial.
	\item {\small\url{https://github.com/rkujawa/busspace-eurobsdcon2012}}
	\item {\small\url{https://github.com/rkujawa/gxemul-eurobsdcon2012}}
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Questions}

\begin{itemize}
	\item Do you have any questions?
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{End\ldots}
\vspace*{-0.8cm}
\begin{center}
\includegraphics[scale=0.5]{NetBSD.png}

Thank you!
\end{center}
\end{frame}

 
\end{document}
